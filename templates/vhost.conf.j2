<VirtualHost *:{{ apache_http_port }}>

  ServerName {{ item.server_name }}
{% if item.aliases is defined %}
  ServerAlias {% for alias in item.aliases %}{{ alias }} {% endfor %}
{% endif %}

  UseCanonicalName on
  DocumentRoot {{ item.document_root }}{% if item.folder is defined %}/{{ item.folder }}{% endif %}


  <Directory /{% if item.folder is defined %}{{ item.folder }}{% endif %}>
    Options +FollowSymLinks -Indexes
    DirectoryIndex index.html index.htm
{% if item.htaccess is defined and item.htaccess == false %}
    AllowOverride None
{%   else %}
    AllowOverride All
{% endif %}

{% if item.auth is defined %}
{%   if item.auth.htaccess is defined %}
    AuthName "Restricted"
    AuthType Basic
    AuthUserFile /etc/htpasswd/{{ item.auth.htaccess.name}}
    Require valid-user
{%   endif %}
{%   if item.auth.ip is defined and item.auth.ip.forwarded is defined %}
{%   for ip in item.auth.ip.forwarded %}
    SetEnvIf X-Forwarded-For "{{ ip.ip }}" {{ ip.name }}
    Require env {{ ip.name }}
{%   endfor %}
{%   endif %}
{%   if item.auth.ip is defined and item.auth.ip.direct is defined %}
    Require ip {{ item.auth.ip.direct }}
{%   endif %}
    Deny from all
    Satisfy Any
{% else %}
    Require all granted
{% endif %}
  </Directory>

  <LocationMatch ^/(\?q=)?user(/?.*)$ >
{% if item.auth is defined %}
    AuthName "Restricted"
    AuthType Basic
    AuthUserFile /etc/htpasswd/{{ item.auth.htaccess.name }}
    Require valid-user
{% else %}
# Allows access to /user only through SSL
    Require expr %{HTTP:X-Forwarded-Proto} == 'https'
{% endif %}
  </LocationMatch>

{% if item.newrelic is defined %}
  <IfModule php5_module>
    php_value newrelic.appname "{{ item.server_name }}"
  </IfModule>
{% endif %}

  <IfModule remoteip_module>
    RemoteIPHeader X-Forwarded-For
    RemoteIPInternalProxy 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16 169.254.0.0/16 127.0.0.0/8
  </IfModule>

  LogLevel info
  ErrorLog /var/log/apache2/{{ item.server_name }}-error.log
{% if item.elb == true %}
  LogFormat "\"%a\" %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\" %D" combined-elb
  CustomLog /var/log/apache2/{{ item.server_name }}-access.log combined-elb
{% else %}
  CustomLog /var/log/apache2/{{ item.server_name }}-access.log combined
{% endif %}

{% if item.filesmatch == true %}
  <FilesMatch "\.(ttf|otf|eot|woff)$">
    <IfModule mod_headers.c>
      Header set Access-Control-Allow-Origin "*"
    </IfModule>
  </FilesMatch>
{% endif %}

  <IfModule rewrite_module>
    RewriteEngine On
{% if item.rewrite is defined %}
{%   for rule in item.rewrite %}
    RewriteRule {{ rule.path }} {{ rule.rule }}
{%   endfor %}
{% endif %}
  </IfModule>

{% if item.fcgi == true %}
  <IfModule proxy_fcgi_module>
    <Proxy *>
      AddDefaultCharset off
      Require all granted
    </Proxy>
    ProxyPassMatch ^/(.*\.php(/.*)?)$ fcgi://127.0.0.1:9000{{ item.document_root }}{% if item.folder is defined %}/{{ item.folder }}{% endif %}/$1
  </IfModule>
{% elif item.origin is defined and item.origin == true %}

# Serve files that already exist to anyone
RewriteCond /srv/webroot/%{REQUEST_URI} "-f"
RewriteRule "\.(png|jpg|jpeg|gif|svg|pdf|css|js)" - [L]

# If CloudFront asks for a file that does not yet exist AND supplies an itok query string, bootstrap Drupal to see if it can generate the file
RewriteCond  "%{HTTP_USER_AGENT}"  "CloudFront"
RewriteCond /srv/webroot/%{REQUEST_URI} "!-f"
RewriteCond "%{QUERY_STRING}" "itok"
RewriteRule "\.(png|jpg|jpeg|gif|svg|pdf|css|js)" fcgi://127.0.0.1:9000/srv/webroot/web/index.php [P,L]

# Otherwise, return 403 FORBIDDEN
RewriteRule .* - [F,L]

# We should cache only successful requests from CloudFront - anything else might be a transient error
# Also, don't let CloudFront see:
# - 'Link:' headers, which Drupal can generate alongside some error pages, or
# - "Expires:" headers, which Drupal sets to the distant past on any 403 pages it generates internally
<If "%{HTTP_USER_AGENT} =~ /CloudFront/">
  Header always set Cache-Control no-cache "expr=%{REQUEST_STATUS} != '200'"
  Header always unset Expires "expr=%{REQUEST_STATUS} != '200'"
  Header always unset Link
</If>
{% else %}
# Don't cache 404s for real files that don't (yet) exist - the 'always' keyword is needed to match non-success responses
Header always set Cache-Control no-cache "expr=%{REQUEST_STATUS} == 404"
# Prevent Clickjacking
Header always append X-Frame-Options SAMEORIGIN
{% endif %}

</VirtualHost>
